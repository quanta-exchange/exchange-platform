// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventEnvelope {
    #[prost(string, tag="1")]
    pub event_id: ::prost::alloc::string::String,
    #[prost(uint32, tag="2")]
    pub event_version: u32,
    #[prost(string, tag="3")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(uint64, tag="4")]
    pub seq: u64,
    #[prost(message, optional, tag="5")]
    pub occurred_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="6")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub causation_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommandMetadata {
    #[prost(string, tag="1")]
    pub command_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub idempotency_key: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub ts_server: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="6")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub correlation_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PriceLevel {
    #[prost(string, tag="1")]
    pub price: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub quantity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LedgerPosting {
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub currency: ::prost::alloc::string::String,
    #[prost(int64, tag="3")]
    pub amount: i64,
    #[prost(bool, tag="4")]
    pub is_debit: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LedgerEntryAppended {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub entry_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub reference_type: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub reference_id: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub entry_kind: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="6")]
    pub postings: ::prost::alloc::vec::Vec<LedgerPosting>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BookDelta {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(uint32, tag="2")]
    pub depth: u32,
    #[prost(message, repeated, tag="3")]
    pub bids: ::prost::alloc::vec::Vec<PriceLevel>,
    #[prost(message, repeated, tag="4")]
    pub asks: ::prost::alloc::vec::Vec<PriceLevel>,
    #[prost(bool, tag="5")]
    pub is_snapshot: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CandleUpdated {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub interval: ::prost::alloc::string::String,
    #[prost(int64, tag="3")]
    pub open_time_ms: i64,
    #[prost(int64, tag="4")]
    pub close_time_ms: i64,
    #[prost(string, tag="5")]
    pub open: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub high: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub low: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub close: ::prost::alloc::string::String,
    #[prost(string, tag="9")]
    pub volume: ::prost::alloc::string::String,
    #[prost(uint64, tag="10")]
    pub trade_count: u64,
    #[prost(bool, tag="11")]
    pub is_final: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TickerUpdated {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub last_price: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub high_24h: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub low_24h: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub volume_24h: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub quote_volume_24h: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceOrderRequest {
    #[prost(message, optional, tag="1")]
    pub meta: ::core::option::Option<CommandMetadata>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(enumeration="Side", tag="3")]
    pub side: i32,
    #[prost(enumeration="OrderType", tag="4")]
    pub order_type: i32,
    #[prost(string, tag="5")]
    pub price: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub quantity: ::prost::alloc::string::String,
    #[prost(enumeration="TimeInForce", tag="7")]
    pub time_in_force: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelOrderRequest {
    #[prost(message, optional, tag="1")]
    pub meta: ::core::option::Option<CommandMetadata>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetSymbolModeRequest {
    #[prost(message, optional, tag="1")]
    pub meta: ::core::option::Option<CommandMetadata>,
    #[prost(enumeration="SymbolMode", tag="2")]
    pub mode: i32,
    #[prost(string, tag="3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelAllRequest {
    #[prost(message, optional, tag="1")]
    pub meta: ::core::option::Option<CommandMetadata>,
    #[prost(string, tag="2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceOrderResponse {
    #[prost(bool, tag="1")]
    pub accepted: bool,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(uint64, tag="5")]
    pub seq: u64,
    #[prost(message, optional, tag="6")]
    pub accepted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="7")]
    pub reject_code: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub correlation_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelOrderResponse {
    #[prost(bool, tag="1")]
    pub accepted: bool,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(uint64, tag="5")]
    pub seq: u64,
    #[prost(message, optional, tag="6")]
    pub canceled_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="7")]
    pub reject_code: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub correlation_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetSymbolModeResponse {
    #[prost(bool, tag="1")]
    pub accepted: bool,
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(uint64, tag="3")]
    pub seq: u64,
    #[prost(message, optional, tag="4")]
    pub acted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="5")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelAllResponse {
    #[prost(bool, tag="1")]
    pub accepted: bool,
    #[prost(string, tag="2")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(uint64, tag="3")]
    pub seq: u64,
    #[prost(message, optional, tag="4")]
    pub acted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(string, tag="5")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderAccepted {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(enumeration="Side", tag="4")]
    pub side: i32,
    #[prost(enumeration="OrderType", tag="5")]
    pub order_type: i32,
    #[prost(string, tag="6")]
    pub price: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub quantity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderRejected {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub reject_code: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub detail: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderCanceled {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub remaining_quantity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelRejected {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub reject_code: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub detail: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradeExecuted {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub trade_id: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub maker_order_id: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub taker_order_id: ::prost::alloc::string::String,
    #[prost(string, tag="5")]
    pub buyer_user_id: ::prost::alloc::string::String,
    #[prost(string, tag="6")]
    pub seller_user_id: ::prost::alloc::string::String,
    #[prost(string, tag="7")]
    pub price: ::prost::alloc::string::String,
    #[prost(string, tag="8")]
    pub quantity: ::prost::alloc::string::String,
    #[prost(string, tag="9")]
    pub quote_amount: ::prost::alloc::string::String,
    #[prost(string, tag="10")]
    pub fee_buyer: ::prost::alloc::string::String,
    #[prost(string, tag="11")]
    pub fee_seller: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EngineCheckpoint {
    #[prost(message, optional, tag="1")]
    pub envelope: ::core::option::Option<EventEnvelope>,
    #[prost(string, tag="2")]
    pub state_hash: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Side {
    Unspecified = 0,
    Buy = 1,
    Sell = 2,
}
impl Side {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIDE_UNSPECIFIED",
            Self::Buy => "SIDE_BUY",
            Self::Sell => "SIDE_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIDE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIDE_BUY" => Some(Self::Buy),
            "SIDE_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Unspecified = 0,
    Limit = 1,
    Market = 2,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_TYPE_UNSPECIFIED",
            Self::Limit => "ORDER_TYPE_LIMIT",
            Self::Market => "ORDER_TYPE_MARKET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_TYPE_LIMIT" => Some(Self::Limit),
            "ORDER_TYPE_MARKET" => Some(Self::Market),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeInForce {
    Unspecified = 0,
    Gtc = 1,
    Ioc = 2,
    Fok = 3,
}
impl TimeInForce {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
            Self::Gtc => "TIME_IN_FORCE_GTC",
            Self::Ioc => "TIME_IN_FORCE_IOC",
            Self::Fok => "TIME_IN_FORCE_FOK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
            "TIME_IN_FORCE_GTC" => Some(Self::Gtc),
            "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
            "TIME_IN_FORCE_FOK" => Some(Self::Fok),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SymbolMode {
    Unspecified = 0,
    Normal = 1,
    CancelOnly = 2,
    SoftHalt = 3,
    HardHalt = 4,
}
impl SymbolMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SYMBOL_MODE_UNSPECIFIED",
            Self::Normal => "SYMBOL_MODE_NORMAL",
            Self::CancelOnly => "SYMBOL_MODE_CANCEL_ONLY",
            Self::SoftHalt => "SYMBOL_MODE_SOFT_HALT",
            Self::HardHalt => "SYMBOL_MODE_HARD_HALT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYMBOL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SYMBOL_MODE_NORMAL" => Some(Self::Normal),
            "SYMBOL_MODE_CANCEL_ONLY" => Some(Self::CancelOnly),
            "SYMBOL_MODE_SOFT_HALT" => Some(Self::SoftHalt),
            "SYMBOL_MODE_HARD_HALT" => Some(Self::HardHalt),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
